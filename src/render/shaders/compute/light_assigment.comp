#version 460 core

#include "../shader_commons.incl"
#include "../scene_incl.incl"

layout (local_size_x = 16, local_size_y = 9, local_size_z = 1) in;

layout(rg8, binding = 0) writeonly restrict uniform image3D lightOutput;


uniform sampler2D depth_texture;
uniform vec2 u_viewportSize;


struct AABB_LightNodeData
{
	uint light_index;
	int next_index;

    vec4 position;
};
layout (std430, binding = 4) readonly restrict buffer LightNodesBuffer
{
   AABB_LightNodeData data[];
} light_nodes;

const vec2 SHADOW_SAMPLE_KERNELS[8] = 
{
    vec2(0.250, 0.0),
    vec2(-0.319300860, 1.03923047),
    vec2(0.0489135273, 2.68328166),
    vec2(0.402386397, 4.76235247),

    vec2(-0.738515854, 7.20000029),
    vec2(0.699686766, 9.94987488),
    vec2(-0.234196693, 12.9799852),
    vec2(-0.446049154, 16.2665310)
};

uniform int u_maxLightCount;

AABB_LightNodeData get_light_node(int index)
{
    AABB_LightNodeData node = light_nodes.data[index];
   // node.hit_index = index + 1;

    return node;
}

int get_next_light_index(vec3 world_pos, inout int index)
{
   // return -1;
        while(index < u_maxLightCount && index != -3)
        { 
            if(index == -2)
            {
                index++;
                continue;
            }
            
            AABB_LightNodeData node = light_nodes.data[index];

            if(node.next_index == -3)
            {
                return -1;
            }
            else if(node.next_index == -2)
            {
                index = index + 1;
                continue;
            }

            vec3 v = node.position.xyz - world_pos.xyz;
            float d = dot(v, v);

            if(d < node.position.w * node.position.w)
            {
                if(node.next_index == -1)
                {
                    index = index + 1;;
                    return int(node.light_index);
                }
                index = node.next_index;
            }
            else
            {
                if(node.next_index == -1)
                {
                    index = index + 1;
                    continue;
                }
                index = node.next_index;    
           
            }
        }
       
    return -1;
}

void main()
{
	 ivec2 iCoords = ivec2(gl_GlobalInvocationID.xy);

    //Make sure we are not processing more than we need to
    if (any(greaterThanEqual(iCoords, u_viewportSize))) 
    { 
		return;
	}

   


}