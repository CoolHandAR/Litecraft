//Inspired by godot's implementation https://github.com/godotengine/godot/blob/master/servers/rendering/renderer_rd/shaders/particles_copy.glsl

#version 460 core

#include "../scene_incl.incl"
#include "../shader_commons.incl"
#include "../particles_common.incl"

#define Math_TAU 6.2831853071795864769252867666

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct Particle
{
    mat4 xform;
    vec3 velocity;
    uint state_flags;
    uint local_index;
    uint emitter_index;
    vec4 color;
};

layout(std430, binding = 5) restrict buffer ParticleEmittersBuffer
{
    ParticleEmitter data[];
} emitters;
layout(std430, binding = 6) restrict buffer ParticlesBuffer
{
    Particle data[];
} particles;

layout(std430, binding = 7) restrict buffer TransformsBuffer
{
    vec4 data[];
} instances;

layout(std430, binding = 8) restrict buffer ColliderBoxesBuffer
{
    vec4 data[];
} col_boxes;

uint hash(uint x)
{
    x = ((x >> uint(16)) ^ x) * uint(0x45d9f3b);
	x = ((x >> uint(16)) ^ x) * uint(0x45d9f3b);
	x = (x >> uint(16)) ^ x;
	return x;
}


uniform int u_totalParticleAmount;
uniform sampler2D depth_texture;
uniform sampler2D gNormal_texture;

void main()
{
    uint particle_index = gl_GlobalInvocationID.x;

#define PARTICLE particles.data[particle_index]
    
    if(particle_index > u_totalParticleAmount)
    {
        return;
    }

#define EMITTER emitters.data[PARTICLE.emitter_index]

    if(bool(EMITTER.state_flags & EMITTER_STATE_FLAG_CLEAR))
    {
        PARTICLE.xform = mat4(1.0);
        PARTICLE.velocity = vec3(0.0);
        PARTICLE.color = vec4(0.0);
    }

    mat4 txform;
    vec4 color = vec4(1, 1, 1, 1);
    vec4 custom = vec4(1, 0, 0, 0);
    bool restart = false;
    float local_delta = EMITTER.delta;
    uint seed = EMITTER.cycle;
    float random = 1;


    if(bool(EMITTER.state_flags & EMITTER_STATE_FLAG_EMITTING))
    {
        float restart_phase = float(PARTICLE.local_index) / float(EMITTER.particle_amount);

        
        if(restart_phase >= EMITTER.time)
        {
            seed -= uint(1);
        }

        seed *= EMITTER.particle_amount;
        seed += PARTICLE.local_index;

        random = float(hash(seed) % uint(65536)) / 65536.0;

        if(EMITTER.randomness > 0)
        {
            restart_phase += EMITTER.randomness * random * 1.0 / float(EMITTER.particle_amount);   
        }
        restart_phase *= (1.0 - EMITTER.explosiveness);
       
        if(EMITTER.time > EMITTER.prev_time)
        {
            if(restart_phase >= EMITTER.prev_time && restart_phase < EMITTER.time)
            {
                restart = true;
                local_delta = (EMITTER.time - restart_phase) * EMITTER.life_time;
            }
        }
        else if(EMITTER.delta > 0.0)
        {
            if(restart_phase >= EMITTER.prev_time)
            {
                restart = true;
                local_delta = (1.0 - restart_phase + EMITTER.time) * EMITTER.life_time;
            }
            else if(restart_phase < EMITTER.time)
            {
                restart = true;
                local_delta = (EMITTER.time - restart_phase) * EMITTER.life_time;
            }
        }
    }
    if(restart)
    {
        if(bool(EMITTER.state_flags & EMITTER_STATE_FLAG_EMITTING))
        {
            float random2 = float(hash(seed + 2) % uint(65536)) / 65536.0;

            vec3 v = EMITTER.direction.xyz;

            if(EMITTER.spread > 0)
            {
                vec3   v1, v2, k;
                float  c, s;

                float angle = radians((random * 2.0 - 1.0) * EMITTER.spread);
                float angle2 = radians((random2 * 2.0 - 1.0) * (1.0 - 0.0) * EMITTER.spread);

                c = cos(angle) * cos(angle2);
                s = sin(angle) * sin(angle2);

                k = normalize(vec3(0, 1, 0));


            /* Right Hand, Rodrigues' rotation formula:
                v = v*cos(t) + (kxv)sin(t) + k*(k.v)(1 - cos(t))
            */
                v1 = v * c;
                v2 = cross(k, v);
                v2 = v2 * s;
                v1 = v1 + v2;
                v2 = k * dot(k, v) * (1.0 - c);
                v = v1 + v2;

            }
            
            float initial_velocity =  EMITTER.initial_velocity * mix(1.0, random, 0.0);

            PARTICLE.xform = EMITTER.xform;
            PARTICLE.velocity = vec3(v.xyz * initial_velocity);
            PARTICLE.state_flags = PARTICLE_STATE_FLAG_EMITTING;

            if(EMITTER.scale != 1.0)
            {
                float scale = EMITTER.scale;
                PARTICLE.xform[0].xyz *= scale;
                PARTICLE.xform[1].xyz *= scale;
                PARTICLE.xform[2].xyz *= scale;
                PARTICLE.xform[3].xyz -= scale;

            }

            switch(EMITTER.emission_shape)
            {
                case EMITTER_EMISSION_SHAPE_POINT:
                {
                    //Do nothing
                    break;
                }
                case EMITTER_EMISSION_SHAPE_BOX:
                {
                    float random3 = float(hash(seed + 4) % uint(65536)) / 65536.0;
                    PARTICLE.xform[3].xyz += vec3(random * 2.0 - 1.0, random2 * 2.0 - 1.0, random3 * 2.0 - 1.0) * EMITTER.emission_size.xyz;
                    break;
                }
                case EMITTER_EMISSION_SHAPE_SPHERE:
                {
                    float random3 = float(hash(seed + 4) % uint(65536)) / 65536.0;

                    float emission_radius = EMITTER.emission_size.x; //the radius is always stored in x 
                    float s = 2.0 * random - 1.0;
                    float t = float(Math_TAU) * random2;
                    float x = random3;
                    float radius = emission_radius * sqrt(1.0 - s * s);
                    PARTICLE.xform[3].xyz = mix(PARTICLE.xform[3].xyz, vec3(radius * cos(t), radius * sin(t), emission_radius * s), x);
                    break;
                }
                case EMITTER_EMISSION_SHAPE_MAX:
                {
                    break;
                }
                default:
                    break;

            }    
        }
        //Not emitting
        else
        {
            PARTICLE.state_flags = 0;
        }
        
    }

    if(bool(PARTICLE.state_flags & PARTICLE_STATE_FLAG_EMITTING) && bool(EMITTER.state_flags & EMITTER_STATE_FLAG_EMITTING))
    {
         vec3 velForce = vec3(0, -EMITTER.gravity, 0);
         if(EMITTER.initial_velocity > 0)
         {
            velForce += normalize(PARTICLE.velocity.xyz) * EMITTER.linear_accel;
         }
         
         float velLength = length(PARTICLE.velocity.xyz);
         velLength -= EMITTER.friction * local_delta; 
         if(velLength > 0.0)
         {
            PARTICLE.velocity.xyz = normalize(PARTICLE.velocity.xyz) * velLength;
         }
         else
         {
            PARTICLE.velocity.xyz = vec3(0.0);
         }

     
         bool perform_depth_collision = false;
         vec3 newPosition = vec3(0.0);
         vec3 newVelocity = PARTICLE.velocity.xyz + velForce * local_delta;
         if(perform_depth_collision)
         {

            vec2 spriteSize = vec2(1, 1);
            float radiusScale = 12;
            float radiusBias = 0.01;
            float radius = min(spriteSize.x, spriteSize.y) * radiusScale + radiusBias;

            vec3 halfVelocity = PARTICLE.velocity.xyz + (velForce.xyz * 0.5);
            vec3 deltaPosition = local_delta * halfVelocity;
            newPosition = PARTICLE.xform[3].xyz + deltaPosition;
             newVelocity = PARTICLE.velocity.xyz + velForce * local_delta;
            
            vec3 collisionOffset = normalize(deltaPosition) * radius;

            vec4 collisionPosition = vec4(PARTICLE.xform[3].xyz + collisionOffset, 1.0);
            
            //View space
            collisionPosition = cam.view * collisionPosition;

            //Clip space
            collisionPosition = cam.proj * collisionPosition;

            vec2 screenPosition = collisionPosition.xy / collisionPosition.w;

            
            if(all(lessThanEqual(abs(screenPosition.xy), vec2(1, 1))))
            {
                vec2 screenUv = screenPosition;
                vec3 sampleWorldPos = depthToViewPos(depth_texture, cam.invProj, screenUv);
                sampleWorldPos = (cam.invView * vec4(sampleWorldPos, 1.0)).xyz;
                float CollisionDepthBounds = 24;
                if(abs(collisionPosition.w - sampleWorldPos.z) < CollisionDepthBounds)
                {
                    vec3 normal = texture(gNormal_texture, screenUv).xyz * 2.0 - 1.0;

                    vec4 collisionPlane = vec4(normal, dot(sampleWorldPos.xyz, normal));

                    float velocityDot = dot(collisionPlane.xyz, deltaPosition.xyz);

                    float d_back = dot(collisionPlane.xyz, PARTICLE.xform[3].xyz) + radius - collisionPlane.w;
                    float d_front = dot(collisionPlane.xyz, newPosition) - radius - collisionPlane.w;
                     newVelocity *= -1;
                        PARTICLE.xform[3].xyz = vec3(0.0);
                    
                       // PARTICLE.xform[3].xyz = vec3(-111111111);
                    if(d_back >= 0.0 && d_front <= 0.0 && velocityDot < 0.0)
                    {
                        

                     
                       newVelocity *= -1;
                        PARTICLE.xform[3].xyz = vec3(0.0);
                      // velForce
                    }
                    else if (d_front < 0.0f && d_back < 0.0f)
			        {
				       //PARTICLE.xform[3].xyz = vec3(-111111111);
			        }
                }
            }

         }

         PARTICLE.velocity.xyz += velForce * local_delta;
         PARTICLE.xform[3].xyz += PARTICLE.velocity.xyz * local_delta;

          bool draw = true;

         //Check for the skip draw flag
         if(bool(EMITTER.state_flags & EMITTER_STATE_FLAG_SKIP_DRAW))
         {
            //Only skip drawing if the particle was not previously visible
            if(!bool(PARTICLE.state_flags & PARTICLE_STATE_FLAG_PREV_VISIBILE))
            {
                draw = false;
            }
         }

      

         if(draw)
         {
            txform = PARTICLE.xform;
            color = PARTICLE.color;

            //Billboard to camera view
            vec3 toCamera = normalize(cam.position.xyz - txform[3].xyz);
            vec3 up = vec3(0.0, 1.0, 0.0);

            vec3 vel = PARTICLE.velocity.xyz;
            vec3 screen_velocity = vel - toCamera * dot(toCamera, vel);

            if(length(screen_velocity) == 0)
            {
                screen_velocity = up;
            }

            screen_velocity = normalize(screen_velocity);

            txform[0].xyz = normalize(cross(screen_velocity, toCamera)) * length(txform[0]);
            txform[1].xyz = screen_velocity * length(txform[1]);
            txform[2].xyz = toCamera * length(txform[2]);

            PARTICLE.state_flags |= PARTICLE_STATE_FLAG_PREV_VISIBILE;
         }
         else
         {
            //culled
            txform = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(-1.0 / 0.0, -1.0 / 0.0, -1.0 / 0.0, 0.0));
            color = vec4(0.0, 0.0, 0.0, 0.0);
            custom = vec4(0.0);

            PARTICLE.state_flags &= ~PARTICLE_STATE_FLAG_PREV_VISIBILE;
         }
    }
    else
    {
         //culled
        txform = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(-1.0 / 0.0, -1.0 / 0.0, -1.0 / 0.0, 0.0));
        color = vec4(0.0, 0.0, 0.0, 0.0);
        custom = vec4(0.0);
    }
   

    custom.x = uint(PARTICLE.emitter_index);
    custom.y = uint(PARTICLE.state_flags);
    

    txform = transpose(txform);

    //write the particle data into a instance buffer
    uint write_offset = gl_GlobalInvocationID.x * (3 + 1 + 1); //xform + color + custom

    instances.data[write_offset + 0] = txform[0];
    instances.data[write_offset + 1] = txform[1];
    instances.data[write_offset + 2] = txform[2];
    instances.data[write_offset + 3] = color; //color 
    instances.data[write_offset + 4] = custom; //custom
}