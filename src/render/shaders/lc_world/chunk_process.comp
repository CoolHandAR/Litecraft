#version 460 core

#include "../scene_incl.incl"
#include "lc_world_incl.incl"

layout (local_size_x = 16, local_size_y = 1, local_size_z = 1) in;

struct CombinedChunkDrawCmdData
{
	//OPAQUES
	uint o_count;
	uint o_first;

	//TRANSPARENTS
	uint t_count;
	uint t_first;

    //WATER
	uint w_count;
	uint w_first;
};

struct DrawArraysIndirectCommand
{
    uint  count;
    uint  instanceCount;
    uint  first;
    uint  baseInstance;
};

struct LC_WorldUniformBuffer
{
	uint opaque_update_offset;
	int opaque_update_move_by;

	uint transparent_update_offset;
	int transparent_update_move_by;

    uint water_update_offset;
	int water_update_move_by;

	int skip_opaque_owner;
	int skip_transparent_owner;
    int skip_water_owner;

	uint chunk_amount;
};

layout (shared, binding = 6) uniform LCWorldBuffer
{
    LC_WorldUniformBuffer lc_world_data;
};


layout (std430, binding = 16) restrict buffer DrawCmdsBuffer
{
    CombinedChunkDrawCmdData data[];
} chunk_draw_cmds;

layout (std430, binding = 19) readonly restrict buffer VisiblesBuffer
{
    uint data[];
} visibles;

layout (std430, binding = 20) writeonly restrict buffer SortedDrawCmdsBuffer
{
   DrawArraysIndirectCommand chunk_draw_cmds_sorted[];
};

layout (std430, binding = 21) restrict buffer CounterBuffer
{
  uint atomic_counter;
};

layout (std430, binding = 22) restrict buffer TransparentCounterBuffer
{
  uint atomic_counter_transparent;
};
layout (std430, binding = 23) restrict buffer WaterCounterBuffer
{
  uint atomic_counter_water;
};



uniform uint u_TotalChunkAmount;

uniform uint u_OpaqueUpdateOffset;
uniform int u_OpaqueUpdateMoveBy;

uniform uint u_TransparentUpdateOffset;
uniform int u_TransparentUpdateMoveBy;

uniform int u_skipOwnerUpdate;
uniform int u_skipTransparentOwnerUpdate;



void main()
{
    uint index = gl_GlobalInvocationID.x;

    if(index == 0)
    {
      atomicExchange(atomic_counter, 0);
      atomicExchange(atomic_counter_transparent, 0);
      atomicExchange(atomic_counter_water, 0);
    }

     //make sure we aren't processing more chunks than we need to
    if(index >= u_TotalChunkAmount)
    {
       // return;
    }
    
    uint query_index = index / 32;
    uint local_index = index % 32;

    uint visible_bitset = visibles.data[query_index];
    bool in_frustrum = bool(visible_bitset >> local_index & uint(1));


#define CHUNK chunk_data.data[index]
#define DRAWCMD chunk_draw_cmds.data[index]
    
    uint total_vert_count = DRAWCMD.o_count + DRAWCMD.t_count;
    
    //Is the chunk completely empty?
    if(total_vert_count == 0)
    {
        return;
    }

     //Update offsets and vertex counts of the draw cmd
     if(lc_world_data.opaque_update_move_by != 0)
     {
        if(DRAWCMD.o_count > 0)
        {
            if(DRAWCMD.o_first > lc_world_data.opaque_update_offset)
            {
                DRAWCMD.o_first += lc_world_data.opaque_update_move_by;
            }
            else if(DRAWCMD.o_first == lc_world_data.opaque_update_offset && lc_world_data.skip_opaque_owner != index)
            {
                DRAWCMD.o_count += lc_world_data.opaque_update_move_by;
            }
        }
     }
     if(lc_world_data.transparent_update_move_by != 0)
     {
        if(DRAWCMD.t_count > 0)
        {
            if(DRAWCMD.t_first > lc_world_data.transparent_update_offset)
            {
                DRAWCMD.t_first += lc_world_data.transparent_update_move_by;
            }
            else if(DRAWCMD.t_first == lc_world_data.transparent_update_offset && lc_world_data.skip_transparent_owner != index)
            {
                DRAWCMD.t_count += lc_world_data.transparent_update_move_by;
            }
        }
     }
    if(lc_world_data.water_update_move_by != 0)
     {
        if(DRAWCMD.w_count > 0)
        {
            if(DRAWCMD.w_first > lc_world_data.water_update_offset)
            {
                DRAWCMD.w_first += lc_world_data.water_update_move_by;
            }
            else if(DRAWCMD.w_first == lc_world_data.water_update_offset && lc_world_data.skip_water_owner != index)
            {
                DRAWCMD.w_count += lc_world_data.water_update_move_by;
            }
        }
     }

       

    //Perform frustrum check
    if(in_frustrum == false)
    {
        //not in frustrum
        CHUNK.vis_flags = 0; //reset vis flags
        return;
    }

    bool skip_occlusion_check = false;

    uint flags = 0;

    //was this chunk previously in frustrum?
    if(bool(CHUNK.vis_flags & CHUNK_FLAG_IN_FRUSTRUM) == false)
    {
        //if this chunk was not previously in frustrum
        //we will skip the occlusion check
        skip_occlusion_check = true;
    }

    //skip_occlusion_check = true;

    //If we got here, that means we are in frustrum
    flags |= CHUNK_FLAG_IN_FRUSTRUM;

    //if this chunk failed the oclussion test, was not visible in the last frame and was in frustrum, we skip drawing this chunk
    if(bool(CHUNK.vis_flags & CHUNK_FLAG_VISIBLE) == true  || skip_occlusion_check == true)
    {
        if(bool(CHUNK.vis_flags & CHUNK_FLAG_PREV_VISIBLE) == false)
        {
            flags |= CHUNK_FLAG_PREV_VISIBLE;
        }

        DrawArraysIndirectCommand draw_cmd;

         //If we got here, this means this chunk is visible
        if(DRAWCMD.t_count > 0)
        {
            draw_cmd.instanceCount = 1;
            draw_cmd.first = DRAWCMD.t_first;
            draw_cmd.count = DRAWCMD.t_count;
            draw_cmd.baseInstance = index;

            uint counter = atomicAdd(atomic_counter_transparent, 1);
            chunk_draw_cmds_sorted[counter + 2000] = draw_cmd;

        }
        if(DRAWCMD.o_count > 0)
        {
            draw_cmd.instanceCount = 1;
            draw_cmd.first = DRAWCMD.o_first;
            draw_cmd.count = DRAWCMD.o_count;
            draw_cmd.baseInstance = index;
          
            uint counter = atomicAdd(atomic_counter, 1);
            chunk_draw_cmds_sorted[counter] =  draw_cmd;
        }
        if(DRAWCMD.w_count > 0)
        {
            draw_cmd.instanceCount = 1;
            draw_cmd.first = DRAWCMD.w_first;
            draw_cmd.count = DRAWCMD.w_count;
            draw_cmd.baseInstance = index;
          
            uint counter = atomicAdd(atomic_counter_water, 1);
            chunk_draw_cmds_sorted[counter + 4000] =  draw_cmd;
        }
    }
    
    CHUNK.vis_flags = flags;    
}