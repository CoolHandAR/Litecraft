#version 460 core

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

struct DrawArraysIndirectCommand
{
    uint  count;
    uint  instanceCount;
    uint  first;
    uint  baseInstance;
};
struct DrawElementsIndirectCommand
{
    uint  count;
    uint  instanceCount;
    uint  firstIndex;
    int   baseVertex;
    uint  baseInstance;
};
struct RenderRequest
{
    mat4 xform;
    vec4 bounding_box[2];
    uint mesh_index;
    int material_index;
    uint flags;
};

uniform sampler2D hiz_map_texture;

uniform CullGlobals
{
    bool distance_cull;
    bool skip_occlussion_culling;
    uint min_vertex_count_for_cull;
    uint min_index_count_for_cull;
    float distance_to_cull;
} cull_globals;

layout (std140, binding = 0) uniform CameraData
{
    mat4 viewProjectionMatrix;
    mat4 view;
    vec4 frustrum_planes[6];
    vec3 position;
    ivec2 screen_size;

    float z_near;
    float z_far;
} camera;

layout (std430, binding = 0) readonly restrict buffer RenderRequestsBuffer
{
	RenderRequest data[];
} render_requests;
layout (std430, binding = 0) writeonly restrict buffer InstanceData
{
	vec4 data[];
} instances;
layout (std430, binding = 0) writeonly restrict buffer DrawElementsCommandsBuffer
{
	DrawElementsIndirectCommand data[];
} draw_elements_cmds;

bool AABB_In_Frustrum(vec4 aabb[2])
{
    vec4 p;
    float dp;

    for(int i = 0; i < 6; i++)
    {
        p = camera.frustrum_planes[i];

        int i1 = int(p.x > 0.0);
        int i2 = int(p.y > 0.0);
        int i3 = int(p.z > 0.0);

        dp = p.x * aabb[i1].x + 
             p.y * aabb[i2].y +
             p.z * aabb[i3].z;

        if(dp < -p.w)
            return false;
    }

    return true;
}

bool Hiz_Cull(vec4 aabb[2])
{
    aabb[0] = camera.viewProjectionMatrix * aabb[0];
    aabb[1] = camera.viewProjectionMatrix * aabb[1];

    aabb[0].xyz /= aabb[0].w;
    aabb[1].xyz /= aabb[1].w;

    vec2 screen_rectangle[2];
    screen_rectangle[0].x = min( aabb[0].x, aabb[1].x ) / 2.0 + 0.5;
    screen_rectangle[0].y = min( aabb[0].y, aabb[1].y ) / 2.0 + 0.5;
    screen_rectangle[1].x = max( aabb[0].x, aabb[1].x ) / 2.0 + 0.5;
    screen_rectangle[1].y = max( aabb[1].y, aabb[1].y ) / 2.0 + 0.5;

    float instance_depth = min(aabb[0].z, aabb[1].z);

    float ndc_width = distance(screen_rectangle[0], screen_rectangle[1]);
    float W = ndc_width * max(camera.screen_size.x, camera.screen_size.y);

    //calculate lod
    float LOD = ceil(log2(W));

    vec4 samples;
    samples.x = textureLod( hiz_map_texture, vec2(screen_rectangle[0].x, screen_rectangle[0].y), LOD ).x;
    samples.y = textureLod( hiz_map_texture, vec2(screen_rectangle[0].x, screen_rectangle[1].y), LOD ).x;
    samples.z = textureLod( hiz_map_texture, vec2(screen_rectangle[1].x, screen_rectangle[1].y), LOD ).x;
    samples.w = textureLod( hiz_map_texture, vec2(screen_rectangle[1].x, screen_rectangle[0].y), LOD ).x;

    float max_depth = max( max( samples.x, samples.y ), max( samples.z, samples.w ) );

    //not visible
    if(instance_depth > max_depth)
    {
        return false;
    }

    //visible
    return true;
}

void main()
{
    uint render_index = gl_GlobalInvocationID.x;

    //Make sure we aren't processing something we don't need to
    if(render_index >= 99)
    {
        return;
    }

#define REQUEST render_requests.data[render_index]

    vec4 aabb[2] = REQUEST.bounding_box;
    aabb[0].w = 1;
    aabb[1].w = 1;

    //not in frustum?
    if(!AABB_In_Frustrum(aabb))
    {
        return;
    }

    bool render = false;
    



    //fill stuff etc
    if(render)
    {

    }
}