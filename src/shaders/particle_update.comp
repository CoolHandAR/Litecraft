#version 460 core

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#define Math_TAU 6.2831853071795864769252867666

#define EMITTER_FLAG_SKIP_DRAW uint(1)
#define EMITTER_FLAG_ACTIVE uint(2)
#define EMITTER_FLAG_CLEAR uint(4)
#define EMITTER_FLAG_FORCE_RESTART uint(8)

#define EMISSION_SHAPE_POINT 0
#define EMISSION_SHAPE_BOX 1
#define EMISSION_SHAPE_SPHERE 2

#define TRANSFORM_ALIGN_SKIP 0
#define TRANSFORM_ALIGN_BILLBOARD 1
#define TRANSFORM_ALIGN_BILLBOARD_VELOCITY 2
#define TRANSFORM_ALIGN_BILLBOARD_VELOCITY_Y 3

struct Particle
{
    mat4 xform;
    vec3 velocity;
    uint emitter_index;
    uint local_index;
    vec4 color;   
};

struct ParticleEmitter
{
    vec4 color;
    vec4 end_color;
    vec3 velocity;
    mat4 xform;
    uint flags;

    float delta;
    float time;
    float prev_time;

    float explosivness;
    float randomness;
    float life_time;

    uint emission_shape;
    vec3 emission_size;

    uint particle_amount;
    uint cycle;

    uint anim_frame;
    uint anim_offset;

    uint transform_align;
};

struct ParticleGlobals
{
    uint max_particle_amount;
    uint max_emitter_amount;
    uint max_transforms_amount;
    uint emitter_flags;
};
uniform ParticleGlobals u_particleGlobals;

struct DrawElementsIndirectCommand
{
    uint  count;
    uint  instanceCount;
    uint  firstIndex;
    int  baseVertex;
    uint  baseInstance;
};

uniform vec3 u_viewPos;
uniform sampler2D u_texture;

layout(std430, binding = 10) readonly restrict buffer ParticleEmitters
{
    ParticleEmitter data[];
} emitters;

layout(std430, binding = 11) restrict buffer Particles
{
    Particle data[];
} particles;

layout(std430, binding = 12) writeonly restrict buffer Transform
{
    vec4 data[];
} instances;

layout(std430, binding = 13) restrict buffer DrawCommands
{
    DrawElementsIndirectCommand data[];
} draw;

layout(binding = 0) uniform atomic_uint ParticleCounter;

mat4 translate(mat4 m, vec3 v)
{
    mat4 matrix = m;
    for(int i = 0; i < 3; i++)
    {
        matrix[3] += m[i] * v[i];
    }

    return matrix;
}

mat4 scale(mat4 m, vec3 v)
{
    m[0].xyz *= v[0];
    m[1].xyz *= v[1];
    m[2].xyz *= v[2];

    return m;
}

uint hash(uint x)
{
    x = ((x >> uint(16)) ^ x) * uint(0x45d9f3b);
	x = ((x >> uint(16)) ^ x) * uint(0x45d9f3b);
	x = (x >> uint(16)) ^ x;
	return x;
}

void main()
{
    uint particle_index = gl_GlobalInvocationID.x;

#define PARTICLE particles.data[particle_index]

    //this should never happen
    if(PARTICLE.emitter_index >= emitters.data.length())
        return;

#define EMITTER emitters.data[PARTICLE.emitter_index]

  //  if(particle_index >= u_particleGlobals.max_particle_amount)
      //  return;

    if(particle_index >= particles.data.length())
        return;

    if(bool(EMITTER.flags & EMITTER_FLAG_CLEAR))
    {
        PARTICLE.xform = mat4(1.0);
        PARTICLE.velocity = vec3(0.0);
        PARTICLE.color = vec4(1.0);
    }
    
    mat4 txform;
    vec4 color;
    vec4 custom;

    if(bool(EMITTER.flags & EMITTER_FLAG_ACTIVE))
    {
        uint local_index = PARTICLE.local_index;

        float local_delta = EMITTER.delta;
        bool restart = false;
        float restart_phase = float(local_index) / float(EMITTER.particle_amount);
        

        //Generate random value
        uint seed = EMITTER.cycle;
        if(restart_phase >= EMITTER.time)
        {
            seed -= uint(1);
        }
        seed *= EMITTER.particle_amount;
        seed += local_index;
        float random = float(hash(seed) % uint(65536)) / 65536.0;
        if(EMITTER.randomness > 0.0)
        {   
            restart_phase += EMITTER.randomness * random * 1.0 / float(EMITTER.particle_amount);
        }
        restart_phase *= (1.0 - EMITTER.explosivness);
        
        if(EMITTER.time > EMITTER.prev_time)
        {
            if(restart_phase >= EMITTER.prev_time && restart_phase < EMITTER.time)
            {
                restart = true;
                local_delta = (EMITTER.time - restart_phase) * EMITTER.life_time;
            }
        }
        else if(EMITTER.delta > 0.0)
        {
            if(restart_phase >= EMITTER.prev_time)
            {
                restart = true;
                local_delta = (1.0 - restart_phase + EMITTER.time) * EMITTER.life_time;
            }
            else if(restart_phase < EMITTER.time)
            {
                restart = true;
                local_delta = (EMITTER.time - restart_phase) * EMITTER.life_time;
            }
        }
        if(restart)
        {
            PARTICLE.xform = EMITTER.xform;
            PARTICLE.velocity = EMITTER.velocity;
            PARTICLE.color = EMITTER.color;

            switch(EMITTER.emission_shape)
            {
                case EMISSION_SHAPE_POINT:
                {
                    break;
                }
                case EMISSION_SHAPE_BOX:
                {
                    float random2 = float(hash(seed + local_index) % uint(65536)) / 65536.0;
                    float random3 = float(hash(seed + local_index * 2) % uint(65536)) / 65536.0;
                    PARTICLE.xform[3].xyz += vec3(random * 2.0 - 1.0, random2 * 2.0 - 1.0, random3 * 2.0 - 1.0) * EMITTER.emission_size;
                    break;
                }
                case EMISSION_SHAPE_SPHERE:
                {
                    float random2 = float(hash(seed + local_index) % uint(65536)) / 65536.0;
                    float random3 = float(hash(seed + local_index * 2) % uint(65536)) / 65536.0;
                    
                    float emission_radius = EMITTER.emission_size.x; //the radius is always stored in x 
                    float s = 2.0 * random - 1.0;
                    float t = float(Math_TAU) * random2;
                    float x = random3;
                    float radius = emission_radius * sqrt(1.0 - s * s);
                    PARTICLE.xform[3].xyz = mix(PARTICLE.xform[3].xyz, vec3(radius * cos(t), radius * sin(t), emission_radius * s), x);
                    break;
                }
                
            }
        }

        //Position  
        //PARTICLE.xform[3].xyz += PARTICLE.velocity * local_delta;

        //end color
        //PARTICLE.color = mix(PARTICLE.color, EMITTER.end_color, local_delta);

        //Update transform
        if(!bool(EMITTER.flags & EMITTER_FLAG_SKIP_DRAW))
        {
            txform = PARTICLE.xform;
            color = PARTICLE.color;
               
            vec3 to_camera = normalize(u_viewPos - txform[3].xyz);
            vec3 up = vec3(0.0, 1.0, 0.0);
            switch(EMITTER.transform_align)
            {
                case TRANSFORM_ALIGN_SKIP:
                {
                    break;
                }
                case TRANSFORM_ALIGN_BILLBOARD:
                {
                    mat3 local = mat3(normalize(cross(up, to_camera)), up, to_camera);
                    local = local * mat3(txform);
                    txform[0].xyz = local[0];
                    txform[1].xyz = local[1];
                    txform[2].xyz = local[2];  
                    break;
                }
                case TRANSFORM_ALIGN_BILLBOARD_VELOCITY:
                {
                    vec3 vel = PARTICLE.velocity;
                    vec3 screen_velocity = vel - to_camera * dot(to_camera, vel);

                    if(length(screen_velocity) == 0)
                    {
                        screen_velocity = up;
                    }

                    screen_velocity = normalize(screen_velocity);

                    txform[0].xyz = normalize(cross(screen_velocity, to_camera)) * length(txform[0]);
                    txform[1].xyz = screen_velocity * length(txform[1]);
                    txform[2].xyz = to_camera * length(txform[2]);
                    break;
                }
                case TRANSFORM_ALIGN_BILLBOARD_VELOCITY_Y:
                {
                    vec3 vel = PARTICLE.velocity;
                    float s = (length(txform[0]) + length(txform[1]) + length(txform[2])) / 3.0;
                    if(length(vel) > 0.0)
                    {
                        txform[1].xyz = normalize(vel);
                    }
                    else
                    {
                        txform[1].xyz = normalize(txform[1].xyz);
                    }
                    txform[0].xyz = normalize(cross(txform[1].xyz, txform[2].xyz));
                    txform[2].xyz = vec3(0.0, 0.0, 1.0) * s;
                    txform[0].xyz *= s;
                    txform[1].xyz *= s;
                    break;
                }
                default:
                {
                    break;
                }
            }

            //update anim frame
            int anim_frame = int(EMITTER.anim_frame);
            //anim_frame += int(EMITTER.anim_offset * random);
            custom = vec4(0, 0, 0, anim_frame); //NULL, NULL, NULL, Animation_frame
        }
        else
        {
            //culled
            txform = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(-1.0 / 0.0, -1.0 / 0.0, -1.0 / 0.0, 0.0));
            color = vec4(0.0, 0.0, 0.0, 0.0);
            custom = vec4(0.0);
        }       
    }
    else
    {
        //culled
        txform = mat4(vec4(0.0), vec4(0.0), vec4(0.0), vec4(-1.0 / 0.0, -1.0 / 0.0, -1.0 / 0.0, 0.0));
        color = vec4(0.0, 0.0, 0.0, 0.0);
        custom = vec4(0.0);
    }


    txform = transpose(txform);

    //write the particle data into a instance buffer
    uint write_offset = gl_GlobalInvocationID.x * (3 + 1 + 1); //xform + color + custom
    
    instances.data[write_offset + 0] = txform[0];
    instances.data[write_offset + 1] = txform[1];
    instances.data[write_offset + 2] = txform[2];
    instances.data[write_offset + 3] = color; //color 
    instances.data[write_offset + 4] = custom; //custom
    

    DrawElementsIndirectCommand command;
    //command.count = 36;
    //command.instanceCount = 64;
    //command.firstIndex = 6;
    //command.baseVertex = 4;
    // command.baseInstance = 0;

        
    //  command.count = 6;
    // command.instanceCount = 64;
    //command.firstIndex = 0;
    //command.baseVertex = 0;
    //command.baseInstance = 0;
    // draw.data[0] = command;

    draw.data[0].instanceCount = 64;

      
    
}