#version 460 core

#include "../shader_commons.incl"
#include "../scene_incl.incl"

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba8, binding = 0) writeonly restrict uniform image2D ssaoOutput;

#define NUM_KERNLES_SAMPLES 32
const vec3 kernelSamples[NUM_KERNLES_SAMPLES] = 
{
		vec3(-0.134, 0.044, -0.825),
		vec3(0.045, -0.431, -0.529),
		vec3(-0.537, 0.195, -0.371),
		vec3(0.525, -0.397, 0.713),
		vec3(0.895, 0.302, 0.139),
		vec3(-0.613, -0.408, -0.141),
		vec3(0.307, 0.822, 0.169),
		vec3(-0.819, 0.037, -0.388),
		vec3(0.376, 0.009, 0.193),
		vec3(-0.006, -0.103, -0.035),
		vec3(0.098, 0.393, 0.019),
		vec3(0.542, -0.218, -0.593),
		vec3(0.526, -0.183, 0.424),
		vec3(-0.529, -0.178, 0.684),
		vec3(0.066, -0.657, -0.570),
		vec3(-0.214, 0.288, 0.188),
		vec3(-0.689, -0.222, -0.192),
		vec3(-0.008, -0.212, -0.721),
		vec3(0.053, -0.863, 0.054),
		vec3(0.639, -0.558, 0.289),
		vec3(-0.255, 0.958, 0.099),
		vec3(-0.488, 0.473, -0.381),
		vec3(-0.592, -0.332, 0.137),
		vec3(0.080, 0.756, -0.494),
		vec3(-0.638, 0.319, 0.686),
		vec3(-0.663, 0.230, -0.634),
		vec3(0.235, -0.547, 0.664),
		vec3(0.164, -0.710, 0.086),
		vec3(-0.009, 0.493, -0.038),
		vec3(-0.322, 0.147, -0.105),
		vec3(-0.554, -0.725, 0.289),
		vec3(0.534, 0.157, -0.250),
};



const float fudge_factor_l0 = 2.0;
const float fudge_factor_l1 = 10.0;

const float sh2_weight_l0 = fudge_factor_l0 * 0.28209; 
const vec3 sh2_weight_l1 = vec3(fudge_factor_l1 * 0.48860);
const vec4 sh2_weight = vec4(sh2_weight_l1, sh2_weight_l0) / NUM_KERNLES_SAMPLES;

const float attenuation_angle_threshold = 0.55;

uniform sampler2D depth_texture;
uniform sampler2D normal_texture;
uniform sampler2D noise_texture;

uniform float u_radius = 0.6;
uniform float u_bias = 0.025;
uniform float u_strength = 5;
uniform vec2 u_viewportSize;
uniform float u_uvMultiplier = 1.0;

vec3 viewNormalAtPixelPosition2(vec2 vpos)
{   
        vec2 pixel_size = 1.0 / u_viewportSize;
    
        // get current pixel's view space position
        vec3 viewSpacePos_c = depthToViewPos(depth_texture, cam.invProj, vpos);
       // viewSpacePos_c = (cam.invView * vec4(viewSpacePos_c, 1.0)).xyz;;

        // get view space position at 1 pixel offsets in each major direction
        vec3 viewSpacePos_l = depthToViewPos(depth_texture, cam.invProj, vpos + vec2( -pixel_size.x, 0.0));
        vec3 viewSpacePos_r = depthToViewPos(depth_texture, cam.invProj, vpos + vec2( pixel_size.x, 0.0));
        vec3 viewSpacePos_d = depthToViewPos(depth_texture, cam.invProj, vpos + vec2( 0.0, -pixel_size.y));
        vec3 viewSpacePos_u = depthToViewPos(depth_texture, cam.invProj, vpos + vec2( 0.0, pixel_size.y));

        vec3 l = viewSpacePos_c - viewSpacePos_l;
        vec3 r = viewSpacePos_r - viewSpacePos_c;
        vec3 d = viewSpacePos_c - viewSpacePos_d;
        vec3 u = viewSpacePos_u - viewSpacePos_c;

        // get the difference between the current and each offset position
        vec3 hDeriv = abs(l.z) < abs(r.z) ? l : r;
        vec3 vDeriv = abs(d.z) < abs(u.z) ? d : u;

        // get view space normal from the cross product of the diffs
        vec3 viewNormal = cross(hDeriv, vDeriv);

		mat3 normalMatrix = transpose(inverse(mat3(cam.invView)));
        viewNormal = normalMatrix * viewNormal;
        viewNormal = normalize(viewNormal);

        return viewNormal;
}

void main()
{
    ivec2 iCoords = ivec2(gl_GlobalInvocationID.xy);

    //Make sure we are not processing more than we need to
    if (any(greaterThanEqual(iCoords, u_viewportSize))) 
    { 
		return;
	}

    vec2 coords = (vec2(iCoords + 0.5) / vec2(u_viewportSize));

    coords *= 1;

	float CenterDepth = texture(depth_texture, coords).r;

	if(CenterDepth >= 1.0)
	{
		imageStore(ssaoOutput, ivec2(gl_GlobalInvocationID.xy), vec4(1));
		return;
	}
	
	vec3 CenterViewPos = depthToViewPosDirect(CenterDepth, cam.invProj, coords);
    vec3 CenterWorldPos = (cam.invView * vec4(CenterViewPos, 1.0)).xyz;
	vec2 NoiseScale = vec2(u_viewportSize.x / 4.0, u_viewportSize.y / 4.0);
	vec3 Noise = texture(noise_texture, coords * NoiseScale).xyz;

	vec3 CenterNormal = normalize(texture(normal_texture, coords).rgb * 2.0 - 1.0);

	vec3 tangent = normalize(Noise - CenterNormal * dot(Noise, CenterNormal));
    vec3 biTangent = cross(CenterNormal, tangent);
    mat3 TBN = mat3(tangent, biTangent, CenterNormal);
	
	float CenterDepthWorldPos = distance(cam.invView[3].xyz, CenterWorldPos.xyz);

	float Radius = 0.6;
	float MaxDistanceInv = 1.0 / max(2.53942, 0.001);

	vec4 occlusion = vec4(0.0);
	for(int i = 0; i < NUM_KERNLES_SAMPLES; i++)
	{	
		vec3 SamplePos = TBN * kernelSamples[i];
        SamplePos = CenterWorldPos + SamplePos * u_radius;
        SamplePos = (cam.view * vec4(SamplePos, 1.0)).xyz;

		vec4 offset = vec4(SamplePos, 1.0);
        offset = cam.proj * offset;
        offset.xyz /= offset.w;
        offset.xy = offset.xy * 0.5 + 0.5;

		vec3 sampleViewPosition = depthToViewPos(depth_texture, cam.invProj, offset.xy);
		vec3 sampleWorldPosition = (cam.invView * vec4(sampleViewPosition, 1.0)).xyz;
		vec3 centerToSample = sampleWorldPosition - CenterWorldPos;
		centerToSample = clamp(centerToSample, vec3(-0.999), vec3(0.999)); //fixes black squares when too close to an object
		float dist = length(centerToSample);
		vec3 centerToSampleNormalized = normalize(centerToSample);
		
		float attenuation = 1.0 - clamp(dist * MaxDistanceInv, 0.0, 1.0);
		float dp = dot(CenterNormal, centerToSampleNormalized);
		
		attenuation = attenuation * attenuation * step(attenuation_angle_threshold, dp);

		float range_check = smoothstep(0.0, 1.0, Radius / max(abs(CenterViewPos.z - sampleViewPosition.z), 0.0001));
		occlusion += (attenuation * vec4(centerToSampleNormalized, 1.0)) * range_check;
	}

	occlusion /= NUM_KERNLES_SAMPLES;
	//occlusion = vec4(occlusion * occlusion * occlusion);

	
	 occlusion = 1.0 - occlusion;

    //occlusion = vec4(occlusion * occlusion * occlusion * occlusion * occlusion);

	//occlusion *= 0.5 + 0.5;

	//occlusion.xyz = CenterNormal;



	//occlusion.w = 1.0 - clamp(occlusion.w, 0.0, 1.0);



	//occlusion.xyzw *= 0.5 + 0.5;



    imageStore(ssaoOutput, ivec2(gl_GlobalInvocationID.xy), vec4(occlusion.xyz, 1.0));
}