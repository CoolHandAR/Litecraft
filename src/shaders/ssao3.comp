#version 460 core
layout (local_size_x = 8, local_size_y = 8) in;

#define KERNEL_SAMPLES_SIZE 32

layout(r16f, binding = 0) writeonly restrict uniform image2D ssaoOutput;


const vec3 kernel_samples[32] = // precalculated hemisphere kernel (low discrepancy noiser)
	{
		vec3(-0.668154, -0.084296, 0.219458),
		vec3(-0.092521,  0.141327, 0.505343),
		vec3(-0.041960,  0.700333, 0.365754),
		vec3( 0.722389, -0.015338, 0.084357),
		vec3(-0.815016,  0.253065, 0.465702),
		vec3( 0.018993, -0.397084, 0.136878),
		vec3( 0.617953, -0.234334, 0.513754),
		vec3(-0.281008, -0.697906, 0.240010),
		vec3( 0.303332, -0.443484, 0.588136),
		vec3(-0.477513,  0.559972, 0.310942),
		vec3( 0.307240,  0.076276, 0.324207),
		vec3(-0.404343, -0.615461, 0.098425),
		vec3( 0.152483, -0.326314, 0.399277),
		vec3( 0.435708,  0.630501, 0.169620),
		vec3( 0.878907,  0.179609, 0.266964),
		vec3(-0.049752, -0.232228, 0.264012),
		vec3( 0.537254, -0.047783, 0.693834),
		vec3( 0.001000,  0.177300, 0.096643),
		vec3( 0.626400,  0.524401, 0.492467),
		vec3(-0.708714, -0.223893, 0.182458),
		vec3(-0.106760,  0.020965, 0.451976),
		vec3(-0.285181, -0.388014, 0.241756),
		vec3( 0.241154, -0.174978, 0.574671),
		vec3(-0.405747,  0.080275, 0.055816),
		vec3( 0.079375,  0.289697, 0.348373),
		vec3( 0.298047, -0.309351, 0.114787),
		vec3(-0.616434, -0.117369, 0.475924),
		vec3(-0.035249,  0.134591, 0.840251),
		vec3( 0.175849,  0.971033, 0.211778),
		vec3( 0.024805,  0.348056, 0.240006),
		vec3(-0.267123,  0.204885, 0.688595),
		vec3(-0.077639, -0.753205, 0.070938)
	};

uniform sampler2D g_normal;
uniform sampler2D noise_texture;
uniform sampler2D depth_texture;

uniform mat4 u_InverseProj;
uniform mat4 u_proj;
uniform mat4 u_InverseView;
uniform mat4 u_view;

 
vec3 calcViewPos(vec2 coords)
{
    float depth = textureLod(depth_texture, coords, 0).r;

    vec4 ndc = vec4(coords.x * 2.0 - 1.0, coords.y * 2.0 - 1.0, depth, 1.0);

    vec4 view_space = u_InverseProj * ndc;

    view_space.xyz = view_space.xyz / view_space.w;

    return view_space.xyz;
}
float radius = 0.6;
float bias = 0.025;
const vec2 noiseScale = vec2(640.0/4.0, 360.0/4.0); 
void main()
{   
    ivec2 iCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 iSize = imageSize(ssaoOutput);
    vec2 tex_coords = (vec2(iCoords + 0.5) / vec2(iSize));
    vec3 fragPos = calcViewPos(tex_coords).xyz;
    vec3 worldPos = (u_InverseView * vec4(fragPos, 1.0)).xyz;
    vec3 normal = normalize(texture(g_normal, tex_coords).rgb);
    vec3 randomVec = normalize(texture(noise_texture, tex_coords * noiseScale).xyz);
    // create TBN change-of-basis matrix: from tangent-space to view-space
    vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));
    vec3 bitangent = cross(normal, tangent);
    mat3 TBN = mat3(tangent, bitangent, normal);
    
    float occlusion = 0.0;
    for(int i = 0; i < KERNEL_SAMPLES_SIZE; ++i)
    {
       // get sample position
        vec3 samplePos = TBN * kernel_samples[i]; // from tangent to view-space
        samplePos = worldPos + samplePos * radius; 
        samplePos = (u_view * vec4(samplePos, 1.0)).xyz;

        // project sample position (to sample texture) (to get position on screen/texture)
        vec4 offset = vec4(samplePos, 1.0);
        offset = u_proj * offset; // from view to clip-space
        offset.xyz /= offset.w; // perspective divide
        offset.xy = offset.xy * 0.5 + 0.5; // transform to range 0.0 - 1.0

        // get sample depth
        float sampleDepth = calcViewPos(offset.xy).z; // get depth value of kernel sample

        // range check & accumulate
        float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth));
        occlusion += (sampleDepth >= samplePos.z + bias ? 1.0 : 0.0) * rangeCheck;     
    }
    occlusion = 1.0 - (occlusion / KERNEL_SAMPLES_SIZE);
    
    ivec2 to_texel = ivec2(floor(tex_coords * iSize));

    //store the texel
    imageStore(ssaoOutput, iCoords, vec4(pow(occlusion, 2), 0.0, 0.0, 0.0));
}