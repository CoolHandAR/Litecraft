#version 460 core

layout (local_size_x = 8, local_size_y = 8) in;

struct DirLight 
{
    vec3 direction;
	
    vec3 color;
    float ambient_intensity;
    float specular_intensity;
};

struct PointLight
{
    vec4 position;

    vec4 color;
    float ambient_intensity;
    float specular_intensity;

    float linear;
    float quadratic;
    float radius;
    float constant;
};

layout(std430, binding = 26) readonly restrict buffer PointLights
{
    PointLight data[];
} pLights;

layout(rgba8, binding = 0) writeonly restrict uniform image2D imgOutput;

uniform sampler2D depth_texture;
uniform sampler2D gNormal;
uniform sampler2D gAlbedo;
uniform sampler2D ssao;

uniform mat4 u_InverseProj;
uniform mat4 u_InverseView;
uniform DirLight u_dirLight;
uniform int u_pointLightCount;

vec3 calcViewPos(vec2 coords)
{
    float depth = textureLod(depth_texture, coords, 0).r;

    vec4 ndc = vec4(coords.x * 2.0 - 1.0, coords.y * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);

    vec4 view_space = u_InverseProj * ndc;

    view_space.xyz = view_space.xyz / view_space.w;

    return view_space.xyz;
}
vec3 calculate_light(vec3 light_color, vec3 light_dir, vec3 normal, vec3 view_dir, float specular_intensity, float shadow_value, float attenuation, float AO)
{
    //AMBIENT
    vec3 ambient = light_color * AO;
    //DIFFUSE
    float diffuse_factor = max(dot(light_dir, normal), 0.0);
    vec3 diffuse = light_color * diffuse_factor;
    //SPECULAR
    vec3 halfway_dir = normalize(light_dir + view_dir);
    float specular_factor = pow(max(dot(normal, halfway_dir), 0.0), 64);
    vec3 specular = light_color * specular_factor * specular_intensity;

    //APPLY ATTENUATION
    ambient *= attenuation;
    diffuse *= attenuation;
    specular *= attenuation;

    return (ambient + diffuse + specular);
}

void main()
{   
    ivec2 iCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 iSize = ivec2(1024, 720);
    vec2 tex_coords = (vec2(iCoords + 0.5) / vec2(iSize));

    // retrieve data from gbuffer
    vec3 FragPos = vec3(u_InverseView * vec4(calcViewPos(tex_coords), 1.0));
    vec3 Normal = texture(gNormal, tex_coords).rgb;
    vec3 Diffuse = texture(gAlbedo, tex_coords).rgb;
    float AO = texture(ssao, tex_coords).r;

    vec3 view_dir = normalize(FragPos); // viewpos is (0.0.0)

    vec3 lighting = vec3(0.0);

    //DIRLIGHT CALC
    lighting = calculate_light(u_dirLight.color * u_dirLight.ambient_intensity, normalize(u_dirLight.direction), Normal, view_dir, u_dirLight.specular_intensity, 1.0, 1, AO);

    //POINT LIGHT CALC
    for(int i = 0; i < u_pointLightCount; i++)
    {
#define pLight pLights.data[i]
        float dist = length(pLight.position.xyz - FragPos);
        if(dist < pLight.radius)
        {
            float attenuation = 1.0 / (pLight.constant + pLight.linear * dist + pLight.quadratic * (dist * dist)); 
            lighting += calculate_light(pLight.color.rgb * pLight.ambient_intensity,  normalize(pLight.position.xyz - FragPos), Normal, view_dir, pLight.specular_intensity, 1.0, attenuation, AO);
        }
    }

    //apply color
    lighting *= Diffuse;
    
    vec4 final_color = vec4(lighting, 1.0);

 
    //ivec2 to_texel = ivec2(floor(tex_coords * iSize));

    //store the texel
    imageStore(imgOutput, iCoords, final_color);
}