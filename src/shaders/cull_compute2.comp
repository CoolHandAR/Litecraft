#version 460 core

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

uniform sampler2D HiZBuffer;

uniform mat4 u_mvp;

#define MIN_VERTEX_COUNT_FOR_HIZ_CULL 1024

struct Camera_data
{
    vec4 frustrum_planes[6];
}; 
struct DrawArraysIndirectCommand
{
    uint count;
    uint instanceCount;
    uint first;
    uint baseInstance;
};
struct DrawElementsIndirectCommand
{
    uint  count;
    uint  instanceCount;
    uint  firstIndex;
    int   baseVertex;
    uint  baseInstance;
};
struct MeshesRenderData
{   
    vec4 bounding_box[2];
    uint index_start;
    uint index_count;
};
struct RenderRequest
{
    mat4 xform;
    uint mesh_index;
};

struct Chunk_info_data
{
    vec4 min_point;
    uint vertex_start;
    uint vertex_count;
};
layout (std140, binding = 1) uniform CAMERA_INFO
{
    Camera_data camera_data;
};
layout(std430, binding = 8) readonly restrict buffer CHUNK_INFO
{
    Chunk_info_data chunk_data[];
};

layout(std430, binding = 6) writeonly restrict buffer DRAW_BUFFER_CMDS
{
    DrawArraysIndirectCommand cmds[];
};


layout(binding = 0) uniform atomic_uint atomic_counter;
uniform vec3 u_viewPos;

bool AABB_in_frustrum(vec4 aabb[2], vec4 frustrum_planes[6])
{
    vec4 p;
    float dp;

    for(int i = 0; i < 6; i++)
    {
        p = frustrum_planes[i];

        int i1 = int(p.x > 0.0);
        int i2 = int(p.y > 0.0);
        int i3 = int(p.z > 0.0);

        dp = p.x * aabb[i1].x + 
             p.y * aabb[i2].y +
             p.z * aabb[i3].z;

        if(dp < -p.w)
            return false;
    }

    return true;
}

void main(void)
{
    uint index = gl_GlobalInvocationID.x;
    if(index >= 32 )
     return;

    Chunk_info_data c_data = chunk_data[index];

    if(c_data.vertex_count == 0)
    {
        return;
    }

    vec4 aabb[2];
    aabb[0] = vec4(c_data.min_point.xyz, 1.0);
    aabb[1] = vec4(c_data.min_point.x + (16 + 0.5), c_data.min_point.y + (16 + 0.5), c_data.min_point.z + (16 + 0.5), 1.0);
    
    vec3 center = vec3(c_data.min_point.xyz + vec3(8, 8, 8));

    bool inFrustum = false;
    bool distance_visible = false;
    if(AABB_in_frustrum(aabb, camera_data.frustrum_planes))
    {
        inFrustum = true;
    }

    //inFrustum = true;

    if(center.z + 16 > 0.1 && center.z - 16 < 500)
    {
        distance_visible = true;
    }
    distance_visible = true;
    if(inFrustum && distance_visible)
    {   
        vec3 aabb_size = abs(vec3(aabb[1].xyz - aabb[0].xyz));

        //set it as visible if the camera is nearby the object
        //its faster and fixes an edge case where the camera is too close to the object
        if(distance(center, u_viewPos) < 32)
        {
             DrawArraysIndirectCommand command;
            command.count = chunk_data[index].vertex_count;
            command.first = chunk_data[index].vertex_start;
            command.instanceCount = 1;
            command.baseInstance = 0;
            
            cmds[atomicCounterIncrement(atomic_counter)] = command;

            return;
        }

        
        //aabb[0].xyz -= 1000;
       // aabb[1].xyz += 1000;
        
        aabb[0] = u_mvp * aabb[0];
        aabb[1] = u_mvp * aabb[1];
        
    if(length(center - u_viewPos) > 1000)
        {
            //aabb[0].xyz -= 500;
            //aabb[1].xyz += 500;
        }

        //aabb[0].xyz *= distance(center, u_viewPos);
        //aabb[1].xyz *= distance(center, u_viewPos);

        aabb[0].xyz /= aabb[0].w;
        aabb[1].xyz /= aabb[1].w;

        vec2 screen_rectangle[2];
        screen_rectangle[0].x = min( aabb[0].x, aabb[1].x ) / 2.0 + 0.5;
        screen_rectangle[0].y = min( aabb[0].y, aabb[1].y ) / 2.0 + 0.5;
        screen_rectangle[1].x = max( aabb[0].x, aabb[1].x ) / 2.0 + 0.5;
        screen_rectangle[1].y = max( aabb[1].y, aabb[1].y ) / 2.0 + 0.5;
        /* then the linear depth value of the front-most point */
        float InstanceDepth = min(aabb[0].z, aabb[1].z);


        float WidthNDC = distance(screen_rectangle[0], screen_rectangle[1]);
        float W = WidthNDC * max(1024, 720);
        /* now we calculate the texture LOD used for lookup in the depth buffer texture */
        float LOD = ceil( log2( W) );
        
        vec4 Samples;
        Samples.x = textureLod( HiZBuffer, vec2(screen_rectangle[0].x, screen_rectangle[0].y), LOD ).x;
        Samples.y = textureLod( HiZBuffer, vec2(screen_rectangle[0].x, screen_rectangle[1].y), LOD ).x;
        Samples.z = textureLod( HiZBuffer, vec2(screen_rectangle[1].x, screen_rectangle[1].y), LOD ).x;
        Samples.w = textureLod( HiZBuffer, vec2(screen_rectangle[1].x, screen_rectangle[0].y), LOD ).x;
        float MaxDepth = max( max( Samples.x, Samples.y ), max( Samples.z, Samples.w ) );

       
        //Not visible
        if(InstanceDepth > MaxDepth)
        {
            //DrawArraysIndirectCommand command;
           // command.count = 0;
            //command.first = 0;
           // command.instanceCount = 0;
           // command.baseInstance = 0;

           // cmds[0] = command;
        }
        //else visible
        else
        {
            DrawArraysIndirectCommand command;
            command.count = chunk_data[index].vertex_count;
            command.first = chunk_data[index].vertex_start;
            command.instanceCount = 1;
            command.baseInstance = 0;
            
            cmds[atomicCounterIncrement(atomic_counter)] = command;

           
        }
    }
    else
    {
       // DrawArraysIndirectCommand command;
        //command.count = 0;
        //command.first = 0;
        //command.instanceCount = 0;
       // command.baseInstance = 0;

       // cmds[0] = command;
    }
}