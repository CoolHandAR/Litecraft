#version 460 core

layout (local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

uniform sampler2D HiZBuffer;

#define MIN_VERTEX_COUNT_FOR_HIZ_CULL 1024

struct Camera_data
{
    vec4 frustrum_planes[6];
}; 
struct DrawElementsIndirectCommand
{
    uint  count;
    uint  instanceCount;
    uint  firstIndex;
    int   baseVertex;
    uint  baseInstance;
};
struct MeshRenderData
{   
    vec4 bounding_box[2];
    int material_index;
};
struct RenderRequest
{
    mat4 xform;
    uint mesh_index;
};

layout (std140, binding = 0) uniform Camera
{
	mat4 g_viewProjectionMatrix;
};

layout (std430, binding = 22) readonly restrict buffer MESH_RENDER_dATA
{
    MeshRenderData data[];
} mesh_render;
layout (std430, binding = 23) writeonly restrict buffer draw_elements
{
   DrawElementsIndirectCommand data[];
} draw_elements_data;

layout (std430, binding = 24) readonly restrict buffer render_requet
{
    RenderRequest data[];
} render_req_data;

layout (std430, binding = 25) writeonly restrict buffer Transforms
{
    vec4 data[];
} transforms;


layout (std140, binding = 1) uniform CAMERA_INFO
{
    Camera_data camera_data;
};

uniform vec3 u_viewPos;

bool AABB_in_frustrum(vec4 aabb[2], vec4 frustrum_planes[6])
{
    vec4 p;
    float dp;

    for(int i = 0; i < 6; i++)
    {
        p = frustrum_planes[i];

        int i1 = int(p.x > 0.0);
        int i2 = int(p.y > 0.0);
        int i3 = int(p.z > 0.0);

        dp = p.x * aabb[i1].x + 
             p.y * aabb[i2].y +
             p.z * aabb[i3].z;

        if(dp < -p.w)
            return false;
    }

    return true;
}

void main(void)
{
    uint index = gl_GlobalInvocationID.x;
    if(index >= 2)
     return;

    RenderRequest render_request = render_req_data.data[index];
    MeshRenderData mesh_data = mesh_render.data[render_request.mesh_index];

    vec4 aabb[2] = mesh_data.bounding_box;
    aabb[0].w = 1;
    aabb[1].w = 1;
    

    vec3 aabb_size = abs(vec3(aabb[1].xyz - aabb[0].xyz));
    aabb[0].xyz += render_request.xform[3].xyz;
    aabb[1].xyz += render_request.xform[3].xyz;


    bool inFrustum = false;
    bool distance_visible = false;
    if(AABB_in_frustrum(aabb, camera_data.frustrum_planes))
    {
        inFrustum = true;
    }


    distance_visible = true;
    if(inFrustum && distance_visible)
    {   
        

      
        aabb[0] = g_viewProjectionMatrix * aabb[0];
        aabb[1] = g_viewProjectionMatrix * aabb[1];
        

        aabb[0].xyz /= aabb[0].w;
        aabb[1].xyz /= aabb[1].w;

        vec2 screen_rectangle[2];
        screen_rectangle[0].x = min( aabb[0].x, aabb[1].x ) / 2.0 + 0.5;
        screen_rectangle[0].y = min( aabb[0].y, aabb[1].y ) / 2.0 + 0.5;
        screen_rectangle[1].x = max( aabb[0].x, aabb[1].x ) / 2.0 + 0.5;
        screen_rectangle[1].y = max( aabb[1].y, aabb[1].y ) / 2.0 + 0.5;
        /* then the linear depth value of the front-most point */
        float InstanceDepth = min(aabb[0].z, aabb[1].z);


        float WidthNDC = distance(screen_rectangle[0], screen_rectangle[1]);
        float W = WidthNDC * max(1024, 720);
        /* now we calculate the texture LOD used for lookup in the depth buffer texture */
        float LOD = ceil( log2( W) );
        
        vec4 Samples;
        Samples.x = textureLod( HiZBuffer, vec2(screen_rectangle[0].x, screen_rectangle[0].y), LOD ).x;
        Samples.y = textureLod( HiZBuffer, vec2(screen_rectangle[0].x, screen_rectangle[1].y), LOD ).x;
        Samples.z = textureLod( HiZBuffer, vec2(screen_rectangle[1].x, screen_rectangle[1].y), LOD ).x;
        Samples.w = textureLod( HiZBuffer, vec2(screen_rectangle[1].x, screen_rectangle[0].y), LOD ).x;
        float MaxDepth = max( max( Samples.x, Samples.y ), max( Samples.z, Samples.w ) );

          
        //Not visible
        if(InstanceDepth > MaxDepth)
        {
            
        }
        //else visible
        else
        {
            mat4 txform = render_request.xform;
            txform = transpose(txform);

            uint ids = atomicAdd(draw_elements_data.data[1].instanceCount, 1);

            uint write_offset = ids * (3 + 1); //xform + custom

            transforms.data[write_offset + 0] = txform[0];
            transforms.data[write_offset + 1] = txform[1];
            transforms.data[write_offset + 2] = txform[2];
            transforms.data[write_offset + 3] = vec4(0, 0, 0, 0);
        }
    }
    else
    {
       
    }
}