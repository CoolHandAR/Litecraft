#version 460 core

#include "../shader_commons.incl"
#include "../scene_incl.incl"

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba8, binding = 0) writeonly restrict uniform image2D ssaoOutput;

uniform vec2 u_viewportSize;
uniform sampler2D depth_texture;
uniform sampler2D ssao_texture;
uniform sampler2D normal_texture;
uniform bool u_secondPass;

const float indices[9] = {-4, -3, -2, -1, 0, +1, +2, +3, +4};


void main()
{
    const ivec2 iCoords = ivec2(gl_GlobalInvocationID.xy);

    //Make sure we are not processing more than we need to
    if (any(greaterThanEqual(iCoords, u_viewportSize))) 
    { 
		return;
	}


    vec2 coords = (vec2(iCoords) / vec2(u_viewportSize));

    vec2 pixel_size = 1.0 / u_viewportSize;

    vec2 blur_step = (u_secondPass ? vec2(0.0, 1.0) : vec2(1.0, 0.0));

	coords += pixel_size * 0.5;

	blur_step *= pixel_size;

    vec3 test_normal;

    test_normal = normalize(texture(normal_texture, coords + indices[4] * blur_step).rgb * 2.0 - 1.0);

    float total_weight = 1.0;
	float discard_threshold = 0.85;
    float weights[9] =
    {
    0.013519569015984728,
    0.047662179108871855,
    0.11723004402070096,
    0.20116755999375591,
    0.240841295721373,
    0.20116755999375591,
    0.11723004402070096,
    0.047662179108871855,
    0.013519569015984728
    };

    for(int i = 0; i < 9; i++)
    {
        vec3 sample_normals = normalize(texture(normal_texture, coords + indices[i] * blur_step).rgb * 2.0 - 1.0);

        if(dot(sample_normals, test_normal) < discard_threshold)
        {
            total_weight -= weights[i];
            weights[i] = 0;
        }
    }

    vec4 accum = vec4(0.0);

    for(int i = 0; i < 9; i++)
    {
        accum += texture(ssao_texture, coords + indices[i] * blur_step) * weights[i];
    }

    accum /= max(total_weight, 0.001);

    imageStore(ssaoOutput, ivec2(gl_GlobalInvocationID.xy), vec4(accum));
}