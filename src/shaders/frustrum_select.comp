#version 460 core

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

#define CHUNK_WIDTH 16
#define CHUNK_HEIGHT 16
#define CHUNK_LENGTH 16

struct Camera_data
{
    vec4 frustrum_planes[6];
};   

struct DrawArraysIndirectCommand
{
    uint count;
    uint instanceCount;
    uint first;
    uint baseInstance;
};

struct Chunk_info_data
{
    vec4 min_point;
    uint vertex_start;
    uint vertex_count;
};

layout(std430, binding = 4) readonly restrict buffer CAMERA_INFO
{
    Camera_data camera_data;
};

layout(std430, binding = 6) writeonly restrict buffer DRAW_BUFFER_CMDS
{
    DrawArraysIndirectCommand cmds[];
};


layout(std430, binding = 8) readonly restrict buffer Chunks_info
{
   Chunk_info_data chunk_data[];
};


layout(binding = 0) uniform atomic_uint atomic_counter;

bool AABB_in_frustrum(vec4 aabb[2], vec4 frustrum_planes[6])
{
    vec4 p;
    float dp;

    for(int i = 0; i < 6; i++)
    {
        p = frustrum_planes[i];

        int i1 = int(p.x > 0.0);
        int i2 = int(p.y > 0.0);
        int i3 = int(p.z > 0.0);

        dp = p.x * aabb[i1].x + 
             p.y * aabb[i2].y +
             p.z * aabb[i3].z;

        if(dp < -p.w)
            return false;
    }

    return true;
}

void main()
{
    uint index = gl_WorkGroupID.x;

    Chunk_info_data c_data = chunk_data[index];

    if(c_data.vertex_count == 0)
    {
        return;
    }

    vec4 aabb[2];
    aabb[0] = c_data.min_point;
    aabb[1] = vec4(c_data.min_point.x + (CHUNK_WIDTH + 0.5), c_data.min_point.y + (CHUNK_HEIGHT + 0.5), c_data.min_point.z + (CHUNK_LENGTH + 0.5), 0.0);

    if(AABB_in_frustrum(aabb, camera_data.frustrum_planes))
    {
        DrawArraysIndirectCommand command;
        command.count = c_data.vertex_count;
        command.first = c_data.vertex_start;
        command.instanceCount = 1;
        command.baseInstance = 0;

        cmds[atomicCounterIncrement(atomic_counter)] = command;     
    }
      

   
}
