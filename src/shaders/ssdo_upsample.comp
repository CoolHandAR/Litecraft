#version 460 core

#include "../shader_commons.incl"
#include "../scene_incl.incl"

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

uniform sampler2D halfsize_depth_texture;
uniform sampler2D halfsize_normal_texture;
uniform sampler2D halfsize_ao_texture_nearest;
uniform sampler2D halfsize_ao_texture_linear;
uniform sampler2D fullsize_depth_texture;

layout(rgba8, binding = 0) writeonly restrict uniform image2D ssaoOutput;

uniform vec2 u_viewportSize;

const ivec2 offsets[4] = {ivec2(0, 0), ivec2(0, 1), ivec2(1, 0), ivec2(1, 1)};
void main()
{
    const ivec2 iCoords = ivec2(gl_GlobalInvocationID.xy);

    //Make sure we are not processing more than we need to
    if (any(greaterThanEqual(iCoords, u_viewportSize))) 
    { 
		return;
	}
    //depth aware upsampling src: https://eleni.mutantstargoat.com/hikiko/depth-aware-upsampling-6/
    vec2 coords = (vec2(iCoords + 0.5) / vec2(u_viewportSize));

    float d0 = texture(fullsize_depth_texture, coords).r;

    float depth_samples[4];
    depth_samples[0] = textureOffset(halfsize_depth_texture, coords, ivec2(0, 0)).r;
    depth_samples[1] = textureOffset(halfsize_depth_texture, coords, ivec2(0, 1)).r;
    depth_samples[2] = textureOffset(halfsize_depth_texture, coords, ivec2(1, 0)).r;
    depth_samples[3] = textureOffset(halfsize_depth_texture, coords, ivec2(1, 1)).r;

    float min_dist = 1.0;

    int best_index = 0;
    for(int i = 0; i < 4; i++)
    {
        float dist = abs(d0 - depth_samples[i]);

        if(min_dist > dist)
        {
            min_dist = dist;
            best_index = i;
        }
    }

    vec4 nearest_ao_sample = textureOffset(halfsize_ao_texture_nearest, coords, offsets[best_index]);

    vec3 normals[4];
    normals[0] = textureOffset(halfsize_normal_texture, coords, ivec2(0, 0)).rgb;
    normals[1] = textureOffset(halfsize_normal_texture, coords, ivec2(0, 1)).rgb;
    normals[2] = textureOffset(halfsize_normal_texture, coords, ivec2(1, 0)).rgb;
    normals[3] = textureOffset(halfsize_normal_texture, coords, ivec2(1, 1)).rgb;

    float dot01 = dot(normals[0], normals[1]);
    float dot02 = dot(normals[0], normals[2]);
    float dot03 = dot(normals[0], normals[3]);

    float min_dot = min(dot01, min(dot02, dot03));
    float s = step(0.997, min_dot);

    vec4 linear_ao_sample = texture(halfsize_ao_texture_linear, coords);

    vec4 final_ao = mix(nearest_ao_sample, linear_ao_sample, s);

    imageStore(ssaoOutput, iCoords, final_ao);
}